---
layout: default
title: "1.4 Building Shopify Apps Using PHP"
nav_order: 4
---

# 1.4 Building Shopify Apps Using PHP

[Building Apps from the Shopify Dev Docs](https://shopify.dev/docs/apps/build)

## The Basic Requirements

### 1. Backend in PHP

* You can use any PHP framework (Laravel, Symfony, Slim, etc.) or even plain PHP.
* Shopify provides [official API libraries](https://github.com/Shopify/shopify-api-php) for PHP, which handle OAuth, REST/GraphQL calls, and session management.

### 2. Authentication

* Apps must support OAuth 2.0 for store installations.
* The PHP library includes helpers for the OAuth handshake, so you don‚Äôt need to implement it all from scratch.

### 3. Handling Webhooks

* Shopify sends webhooks for store events (orders, products, etc.).
* In PHP, you‚Äôd set up routes (endpoints) to receive and verify these signed requests.

### 4. Frontend

* The admin app UI is usually built with Shopify‚Äôs [Polaris React components](https://polaris.shopify.com/).
* You can serve that frontend from your PHP backend, or separate it into a Node/React frontend that calls your PHP API.

### 5. Hosting

* Any environment that supports PHP will work (e.g., Apache/Nginx with PHP-FPM).
* Many developers host apps on services like Heroku, Render, or AWS.

üëâ So, while many Shopify tutorials use Node.js, PHP is fully supported. You just need to follow the app requirements (OAuth, API usage, embedded app SDK if needed).

---

## A Simple Example

Here‚Äôs a tiny, no-framework starter that does exactly two things:

1. OAuth install + callback
2. Makes one Admin API call (`GET /shop.json`) to prove it works

It runs with plain PHP (built-in server), no Composer needed.

---

### 1) App setup (once)

1. In your Shopify Partners dashboard, create an app.
2. Add an allowed **Redirect URL**: `http://localhost:8080/auth/callback`
3. Note your **API key** and **API secret key**.
4. Pick minimal scopes, e.g.: `read_products` (or none for `/shop.json`).

---

### 2) Files

```
shopify-php-minimal/
‚îú‚îÄ index.php
‚îú‚îÄ config.php
‚îú‚îÄ tokens/           # created automatically for demo token storage
```

**config.php**

```php
<?php
// Rename this file and put your creds here for local dev.
// NEVER commit real secrets in production.
const SHOPIFY_API_KEY    = 'YOUR_API_KEY_HERE';
const SHOPIFY_API_SECRET = 'YOUR_API_SECRET_HERE';

// Choose a stable Admin API version. Update as needed.
const SHOPIFY_API_VERSION = '2024-07';

// Your app‚Äôs public URL for dev
const APP_URL = 'http://localhost:8080';
```

**index.php**

```php
<?php
declare(strict_types=1);

require __DIR__ . '/config.php';

// ‚Äî‚Äî‚Äî tiny ‚Äúrouter‚Äù ‚Äî‚Äî‚Äî
$path = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH) ?? '/';

if ($path === '/') {
    echo "<h1>Shopify PHP Minimal</h1>";
    echo "<p>Install the app into a store:</p>";
    echo '<form method="GET" action="/install">
            <input name="shop" placeholder="storename.myshopify.com" required />
            <button type="submit">Install</button>
          </form>';
    exit;
}

if ($path === '/install') {
    $shop = sanitizeShop($_GET['shop'] ?? '');
    if (!$shop) fail('Invalid shop parameter.');

    $scopes = 'read_products'; // adjust as needed
    $state  = bin2hex(random_bytes(12)); // CSRF protection
    $_SESSION ?? session_start();
    $_SESSION['state'] = $state;

    $params = http_build_query([
        'client_id'    => SHOPIFY_API_KEY,
        'scope'        => $scopes,
        'redirect_uri' => APP_URL . '/auth/callback',
        'state'        => $state,
    ]);
    redirect("https://{$shop}/admin/oauth/authorize?{$params}");
}

if ($path === '/auth/callback') {
    $_SESSION ?? session_start();

    $hmac = $_GET['hmac'] ?? '';
    $shop = sanitizeShop($_GET['shop'] ?? '');
    $code = $_GET['code'] ?? '';
    $state = $_GET['state'] ?? '';

    if (!$hmac || !$shop || !$code) fail('Missing OAuth parameters.');
    if (!isset($_SESSION['state']) || !hash_equals($_SESSION['state'], $state)) {
        fail('State mismatch.');
    }

    // Verify HMAC
    $params = $_GET;
    unset($params['hmac'], $params['signature']); // signature is legacy
    ksort($params);
    $query = http_build_query($params, '', '&', PHP_QUERY_RFC3986);
    $computed = hash_hmac('sha256', $query, SHOPIFY_API_SECRET);
    if (!hash_equals($computed, $hmac)) {
        fail('Invalid HMAC.');
    }

    // Exchange code for access token
    $token = exchangeToken($shop, $code);

    // Demo token storage (file). Use a DB in real apps.
    @mkdir(__DIR__ . '/tokens', 0775, true);
    file_put_contents(__DIR__ . "/tokens/{$shop}.json", json_encode([
        'access_token' => $token,
        'installed_at' => time(),
    ], JSON_PRETTY_PRINT));

    echo "<h3>Installed on {$shop}</h3>";
    echo '<p><a href="/shop?shop=' . htmlspecialchars($shop, ENT_QUOTES) . '">Call Admin API (/shop.json)</a></p>';
    exit;
}

if ($path === '/shop') {
    $shop = sanitizeShop($_GET['shop'] ?? '');
    if (!$shop) fail('Missing shop.');

    $dataPath = __DIR__ . "/tokens/{$shop}.json";
    if (!is_file($dataPath)) fail('Store not installed yet.');
    $data = json_decode(file_get_contents($dataPath), true);
    $token = $data['access_token'] ?? null;
    if (!$token) fail('Missing token.');

    $resp = shopApiGet($shop, '/shop.json', $token);
    header('Content-Type: application/json');
    echo $resp;
    exit;
}

http_response_code(404);
echo 'Not Found';
exit;

// ‚Äî‚Äî‚Äî helpers ‚Äî‚Äî‚Äî

function sanitizeShop(string $shop): ?string {
    $shop = trim($shop);
    if ($shop === '') return null;
    // Accept either "storename" or "storename.myshopify.com"
    if (strpos($shop, '.myshopify.com') === false) {
        $shop .= '.myshopify.com';
    }
    // basic validation
    if (!preg_match('/^[a-z0-9][a-z0-9\-]*\.myshopify\.com$/i', $shop)) return null;
    return strtolower($shop);
}

function redirect(string $url): void {
    header("Location: {$url}", true, 302);
    exit;
}

function fail(string $msg): void {
    http_response_code(400);
    echo "<h3>Error</h3><pre>" . htmlspecialchars($msg, ENT_QUOTES) . "</pre>";
    exit;
}

function exchangeToken(string $shop, string $code): string {
    $url = "https://{$shop}/admin/oauth/access_token";
    $payload = json_encode([
        'client_id'     => SHOPIFY_API_KEY,
        'client_secret' => SHOPIFY_API_SECRET,
        'code'          => $code,
    ]);

    $ch = curl_init($url);
    curl_setopt_array($ch, [
        CURLOPT_POST => true,
        CURLOPT_RETURNTRANSFER => true,
        CURLOPT_HTTPHEADER => ['Content-Type: application/json'],
        CURLOPT_POSTFIELDS => $payload,
    ]);
    $resp = curl_exec($ch);
    if ($resp === false) fail('Token exchange failed: ' . curl_error($ch));
    $codeHttp = curl_getinfo($ch, CURLINFO_RESPONSE_CODE);
    curl_close($ch);

    if ($codeHttp < 200 || $codeHttp >= 300) {
        fail("Token exchange HTTP {$codeHttp}: {$resp}");
    }
    $json = json_decode($resp, true);
    $token = $json['access_token'] ?? null;
    if (!$token) fail('No access_token in response.');
    return $token;
}

function shopApiGet(string $shop, string $path, string $token): string {
    $url = "https://{$shop}/admin/api/" . SHOPIFY_API_VERSION . $path;
    $ch = curl_init($url);
    curl_setopt_array($ch, [
        CURLOPT_RETURNTRANSFER => true,
        CURLOPT_HTTPHEADER => [
            'X-Shopify-Access-Token: ' . $token,
            'Accept: application/json',
        ],
    ]);
    $resp = curl_exec($ch);
    if ($resp === false) fail('API call failed: ' . curl_error($ch));
    $codeHttp = curl_getinfo($ch, CURLINFO_RESPONSE_CODE);
    curl_close($ch);

    if ($codeHttp < 200 || $codeHttp >= 300) {
        fail("API HTTP {$codeHttp}: {$resp}");
    }
    return $resp;
}
```

---

### 3) Run it

From the project folder:

```bash
php -S localhost:8080
```

Then:

1. Open `http://localhost:8080/`
2. Enter your store domain (e.g., `mystore.myshopify.com`) ‚Üí **Install**
3. Approve the install in Shopify ‚Üí you‚Äôll land back at `/auth/callback`
4. Click the link to hit `/shop` and see the JSON response

---

### What‚Äôs next (quick pointers)

* Token storage: swap the `tokens/` file for a DB table keyed by `shop`.
* App bridge / embedded UI: serve a small frontend (React/Polaris) at a route like `/` after install.
* Webhooks: add endpoints and verify HMAC using `X-Shopify-Hmac-Sha256` header.
* API versions: bump `SHOPIFY_API_VERSION` periodically.

---

## Adding Shopify's PHP Library

Here‚Äôs the smallest set of changes to ‚Äúwire in‚Äù Shopify‚Äôs official PHP library while keeping your minimal app structure. We‚Äôll keep your existing (working) OAuth flow for now, and use the library for API calls/storage so you can swap OAuth to the library later if you want.

---

### 0) Install the library

From your project folder:

```bash
composer require shopify/shopify-api
```

(Official package on Packagist. ([Packagist][1]))

---

### 1) Update project layout

```
shopify-php-minimal/
‚îú‚îÄ index.php           # updated
‚îú‚îÄ config.php          # updated
‚îú‚îÄ vendor/             # added by Composer
‚îú‚îÄ sessions/           # library‚Äôs file-based session store (new)
‚îî‚îÄ tokens/             # keep for now (your current demo tokens)
```

Create the `sessions/` folder (writable).

---

### 2) config.php (initialize the library)

Add the autoloader and library init. Keep your constants.

```php
<?php
// config.php
const SHOPIFY_API_KEY    = 'YOUR_API_KEY_HERE';
const SHOPIFY_API_SECRET = 'YOUR_API_SECRET_HERE';
const SHOPIFY_API_VERSION = '2024-07';
const APP_URL = 'http://localhost:8080';

require __DIR__ . '/vendor/autoload.php';

use Shopify\Context;
use Shopify\Auth\FileSessionStorage;

// Initialize the library early
Context::initialize(
    apiKey: SHOPIFY_API_KEY,
    apiSecretKey: SHOPIFY_API_SECRET,
    scopes: ['read_products'],                 // adjust as needed
    hostName: parse_url(APP_URL, PHP_URL_HOST),
    sessionStorage: new FileSessionStorage(__DIR__ . '/sessions'),
    apiVersion: SHOPIFY_API_VERSION,
    isEmbeddedApp: false,
    isPrivateApp: false
);
```

(These are the documented knobs for `Context::initialize` and Composer install. ([GitHub][2], [Packagist][1]))

---

### 3) index.php ‚Äî swap your raw cURL call for the official REST client

Leave your existing routes (`/`, `/install`, `/auth/callback`) and OAuth code as-is for now. Replace only the **`/shop`** handler and the helper that called cURL.

**Replace your `/shop` route with:**

```php
if ($path === '/shop') {
    $shop = sanitizeShop($_GET['shop'] ?? '');
    if (!$shop) fail('Missing shop.');

    // Load the token you saved in /auth/callback (unchanged for now)
    $dataPath = __DIR__ . "/tokens/{$shop}.json";
    if (!is_file($dataPath)) fail('Store not installed yet.');
    $data = json_decode(file_get_contents($dataPath), true);
    $token = $data['access_token'] ?? null;
    if (!$token) fail('Missing token.');

    // --- NEW: use Shopify official REST client
    $json = shopApiGetViaLibrary($shop, $token);

    header('Content-Type: application/json');
    echo $json;
    exit;
}
```

**Add this helper somewhere below your helpers:**

```php
use Shopify\Clients\Rest;

function shopApiGetViaLibrary(string $shop, string $token): string {
    // The REST client automatically targets /admin/api/{version}/...
    $client = new Rest($shop, $token);

    // GET /shop.json  -> resource name 'shop'
    $response = $client->get('shop');   // no leading slash, no .json needed

    // $response->getStatusCode(); $response->getHeaders(); $response->getBody();
    return json_encode($response->getDecodedBody(), JSON_PRETTY_PRINT);
}
```

The library resolves the Admin API base path/version and returns a typed response you can inspect (status, headers, decoded JSON). ([Packagist][1])

---

### 4) (Optional next step) Move OAuth to the library

When you‚Äôre ready, you can replace your custom OAuth with the library‚Äôs `OAuth::begin` and `OAuth::callback`. The high-level flow is:

* `/install` ‚Üí `OAuth::begin($shop, '/auth/callback', $isOnline, $rawRequest, $setCookieFn)` returns a redirect URL.
* `/auth/callback` ‚Üí `OAuth::callback($rawRequest, $setCookieFn)` creates/saves a session in your configured `SessionStorage` (we set `FileSessionStorage` in `Context::initialize`), from which you can load the access token later.

Exact parameters are in the **OAuth usage docs** (signatures and required request/cookie plumbing). If you‚Äôd like, I can drop in those two route handlers next. ([GitHub][3])

---

### 5) Why keep this incremental step?

* You get the **official** client for Admin API calls right away (less hand-rolled HTTP, better error/response handling).
* No breaking changes to your working OAuth while you‚Äôre experimenting.
* Swapping OAuth later is a small, contained edit to your `/install` and `/auth/callback` routes, using the same session storage you already initialized.

---

### Sanity checks

* PHP & Composer installed; `vendor/autoload.php` loads. ([GitHub][2])
* Scopes in `Context::initialize` match what you requested in the Partners dashboard.
* `sessions/` is writable; the library stores sessions there.
* Your `tokens/` file usage remains until you fully move to library sessions.

---

[1]: https://packagist.org/packages/shopify/shopify-api?utm_source=chatgpt.com "shopify/shopify-api - Packagist"
[2]: https://github.com/Shopify/shopify-api-php/blob/main/docs/getting_started.md?utm_source=chatgpt.com "shopify-api-php/docs/getting_started.md at main - GitHub"
[3]: https://github.com/Shopify/shopify-api-php/blob/main/docs/usage/oauth.md?utm_source=chatgpt.com "shopify-api-php/docs/usage/oauth.md at main - GitHub"

---

## Adding OAuth From The Shopify PHP Library

Perfect‚Äîhere‚Äôs the drop-in swap to use the library‚Äôs OAuth for `/install` and `/auth/callback`, keeping everything else from your minimal app.

---

### 1) Keep your `config.php` from the last step

(With `Context::initialize(...)` and `FileSessionStorage` set up.)

> The official repo documents OAuth ‚ÄúBegin‚Äù and ‚ÄúCallback‚Äù under **Performing OAuth**. ([GitHub][1])

---

### 2) Update `index.php`

Replace your current `/install` and `/auth/callback` routes with the versions below.
Leave the `/` and `/shop` routes and your other helpers as-is (we‚Äôll no longer use your manual HMAC + token exchange).

```php
<?php
declare(strict_types=1);

require __DIR__ . '/config.php';

use Shopify\Auth\OAuth;
use Shopify\Utils;

$path = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH) ?? '/';

/* ---------- Home (unchanged) ---------- */
if ($path === '/') {
    echo "<h1>Shopify PHP Minimal</h1>";
    echo "<p>Install the app into a store:</p>";
    echo '<form method="GET" action="/install">
            <input name="shop" placeholder="storename.myshopify.com" required />
            <button type="submit">Install</button>
          </form>';
    exit;
}

/* ---------- INSTALL (OAuth begin via library) ---------- */
if ($path === '/install') {
    $shop = sanitizeShop($_GET['shop'] ?? '');
    if (!$shop) fail('Invalid shop parameter.');

    // online=false for classic ‚Äúoffline‚Äù token; set true if you need per-user sessions
    $isOnline = false;

    // Build a request shape the library expects (headers/cookies/query)
    $request = makeLibraryRequest();

    // The library asks you to provide how to set cookies:
    $setCookie = function (string $name, string $value, array $opts = []) {
        // Map library options to PHP's setcookie
        $params = [
            'expires'  => $opts['expires']  ?? 0,
            'path'     => $opts['path']     ?? '/',
            'domain'   => $opts['domain']   ?? '',
            'secure'   => $opts['secure']   ?? false,
            'httponly' => $opts['httpOnly'] ?? true,
            'samesite' => $opts['sameSite'] ?? 'Lax',
        ];
        setcookie($name, $value, $params);
    };

    // This returns a Shopify authorization URL
    $redirectUrl = OAuth::begin(
        shop: $shop,
        redirectPath: '/auth/callback',
        isOnline: $isOnline,
        request: $request,
        setCookieFunction: $setCookie
    );

    header('Location: ' . $redirectUrl, true, 302);
    exit;
}

/* ---------- CALLBACK (OAuth finalize via library) ---------- */
if ($path === '/auth/callback') {
    $request = makeLibraryRequest();

    $setCookie = function (string $name, string $value, array $opts = []) {
        $params = [
            'expires'  => $opts['expires']  ?? 0,
            'path'     => $opts['path']     ?? '/',
            'domain'   => $opts['domain']   ?? '',
            'secure'   => $opts['secure']   ?? false,
            'httponly' => $opts['httpOnly'] ?? true,
            'samesite' => $opts['sameSite'] ?? 'Lax',
        ];
        setcookie($name, $value, $params);
    };

    // This validates HMAC, exchanges the code for a token,
    // and persists a Session via your FileSessionStorage
    OAuth::callback(
        request: $request,
        setCookieFunction: $setCookie
    );

    // After callback, load the saved session to learn which shop installed
    // (offline sessions use shop as the session id)
    $session = Utils::loadCurrentSession(
        $request['headers'],
        $request['cookies'],
        false // $isOnline must match what you used in /install
    );
    if (!$session) fail('No session created.');

    $shop = $session->getShop();
    // You can now stop using /tokens/*.json; the library stores the access token in the session storage.
    // (Optional) show a link that calls the Admin API using the official REST client:
    echo "<h3>Installed on {$shop}</h3>";
    echo '<p><a href="/shop?shop=' . htmlspecialchars($shop, ENT_QUOTES) . '">Call Admin API (/shop.json)</a></p>';
    exit;
}

/* ---------- SHOP (unchanged from prior step except it no longer reads tokens/ ) ---------- */
if ($path === '/shop') {
    $shop = sanitizeShop($_GET['shop'] ?? '');
    if (!$shop) fail('Missing shop.');

    // Build request and load the (offline) session saved by the library
    $request = makeLibraryRequest();
    $session = Utils::loadCurrentSession($request['headers'], $request['cookies'], false);
    if (!$session || strtolower($session->getShop()) !== strtolower($shop)) {
        fail('No valid session for this shop. Reinstall.');
    }

    // Use the official REST client helper you added earlier
    $json = shopApiGetViaLibrary($shop, $session->getAccessToken());

    header('Content-Type: application/json');
    echo $json;
    exit;
}

/* ---------- 404 ---------- */
http_response_code(404);
echo 'Not Found';
exit;

/* ---------- helpers (keep your existing sanitizeShop, fail, redirect, shopApiGetViaLibrary) ---------- */

function sanitizeShop(string $shop): ?string {
    $shop = trim($shop);
    if ($shop === '') return null;
    if (strpos($shop, '.myshopify.com') === false) $shop .= '.myshopify.com';
    if (!preg_match('/^[a-z0-9][a-z0-9\-]*\.myshopify\.com$/i', $shop)) return null;
    return strtolower($shop);
}

/**
 * Build the "request" arrays the library expects for OAuth & session loading.
 */
function makeLibraryRequest(): array {
    // Headers as key=>value (e.g., "User-Agent" => "..."), not the $_SERVER form
    $headers = [];
    foreach ($_SERVER as $key => $val) {
        if (str_starts_with($key, 'HTTP_')) {
            $h = str_replace('_', '-', substr($key, 5));
            $headers[ucwords(strtolower($h), '-')] = $val;
        }
    }
    // For local dev behind php -S, Host may be missing:
    if (!isset($headers['Host']) && isset($_SERVER['HTTP_HOST'])) {
        $headers['Host'] = $_SERVER['HTTP_HOST'];
    }

    return [
        'headers' => $headers,
        'cookies' => $_COOKIE ?? [],
        'query'   => $_GET ?? [],
        'body'    => file_get_contents('php://input') ?: '',
        'method'  => $_SERVER['REQUEST_METHOD'] ?? 'GET',
        'path'    => parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH) ?? '/',
    ];
}
```

**Notes**

* This uses **offline** access by default (`$isOnline = false`). Flip to `true` if you want per-user sessions.
* The library persists sessions to the `FileSessionStorage` you configured in `Context::initialize`, so you can delete your old `tokens/` folder once you‚Äôre confident everything works.

---

### 3) Test flow

1. Start your app:

```bash
php -S localhost:8080
```

2. In Partners > App setup, ensure Redirect URL:
   `http://localhost:8080/auth/callback`

3. Visit `http://localhost:8080/`, enter `storename.myshopify.com`, click **Install**, approve, land on `/auth/callback`.

4. Click the link to `/shop?shop=storename.myshopify.com` to hit `GET /shop.json` via the official REST client.

---

### 4) Why this works

* `OAuth::begin(...)` builds the Shopify authorization URL and sets any cookies the library needs.
* `OAuth::callback(...)` verifies HMAC, exchanges the code for an access token, and saves a **Session** using your configured `SessionStorage`.
* `Utils::loadCurrentSession(...)` loads that Session so you can call the Admin API.
  These steps are what the library‚Äôs ‚ÄúPerforming OAuth‚Äù docs outline. ([GitHub][1])

---

[1]: https://github.com/Shopify/shopify-api-php "GitHub - Shopify/shopify-api-php"

---

## Turning It Into An Embedded App

Let‚Äôs turn your app into an **embedded** app with **App Bridge + session tokens**. We‚Äôll:

1. flip your PHP backend to ‚Äúembedded mode‚Äù
2. serve a tiny App Bridge page that fetches a session token
3. verify that token on the backend before serving data

I‚Äôll keep it minimal and close to what you already have.

---

### 0) Install one extra package

We‚Äôll use a small, widely-used JWT lib to verify session tokens server-side.

```bash
composer require firebase/php-jwt
```

Session tokens are short-lived JWTs signed with your app secret; the backend must verify them. ([Shopify][1])

---

### 1) `config.php`: mark the app embedded

Just change one flag in your existing Shopify library init:

```php
Context::initialize(
    apiKey: SHOPIFY_API_KEY,
    apiSecretKey: SHOPIFY_API_SECRET,
    scopes: ['read_products'],  // your scopes
    hostName: parse_url(APP_URL, PHP_URL_HOST),
    sessionStorage: new FileSessionStorage(__DIR__ . '/sessions'),
    apiVersion: SHOPIFY_API_VERSION,
    isEmbeddedApp: true,        // <<‚Äî embedded
    isPrivateApp: false
);
```

---

### 2) `index.php`: add CSP + a tiny embedded page

Embedded apps must allow Shopify Admin to frame them; set **Content-Security-Policy: frame-ancestors** accordingly. We‚Äôll also ship a tiny HTML page that boots App Bridge and fetches a session token. ([Shopify][2], [DEV Community][3], [Shopify Community][4])

Add this helper near the top (before routing) to emit CSP on every HTML response:

```php
function setCsp(?string $shopDomain = null): void {
    // Allow Shopify Admin + the specific shop to frame this app
    $ancestors = ["https://admin.shopify.com"];
    if ($shopDomain) $ancestors[] = "https://{$shopDomain}";
    header("Content-Security-Policy: frame-ancestors " . implode(' ', $ancestors));
}
```

#### 2a) Serve an embedded page at `/`

Replace your existing home route with this (keeps your install link for non-embedded access, but also serves App Bridge when embedded):

```php
if ($path === '/') {
    // If embedded, Shopify app iframe will include `host` and `shop` in the URL.
    $shop = sanitizeShop($_GET['shop'] ?? '') ?? '';
    setCsp($shop); // allow framing by Admin + this shop

    $apiKey = SHOPIFY_API_KEY;
    $hostParam = htmlspecialchars($_GET['host'] ?? '', ENT_QUOTES);
    $shopParam = htmlspecialchars($shop, ENT_QUOTES);

    // Minimal HTML: App Bridge + getSessionToken -> call /api/ping
    echo <<<HTML
<!doctype html>
<html>
<head><meta charset="utf-8"><title>Shopify PHP Minimal (Embedded)</title></head>
<body>
  <div id="app">Loading‚Ä¶</div>

  <!-- App Bridge (CDN) -->
  <script src="https://unpkg.com/@shopify/app-bridge"></script>
  <script src="https://unpkg.com/@shopify/app-bridge/utilities"></script>

  <script>
    (function() {
      var AppBridge = window['app-bridge'];
      var utils = window['app-bridge'].utilities || window['app-bridge-utilities'];
      var createApp = AppBridge.default;
      var getSessionToken = (utils && utils.getSessionToken) || (window['app-bridge-utils'] && window['app-bridge-utils'].getSessionToken);

      var app = createApp({
        apiKey: "{$apiKey}",
        host: "{$hostParam}",
        forceRedirect: true
      });

      // Get a fresh session token and use it on requests to our backend
      (async function callBackend() {
        try {
          var token = await getSessionToken(app);  // short-lived JWT
          var res = await fetch("/api/ping?shop={$shopParam}", {
            method: "GET",
            headers: { "Authorization": "Bearer " + token }
          });
          var json = await res.json();
          document.getElementById('app').textContent = JSON.stringify(json, null, 2);
        } catch (e) {
          document.getElementById('app').textContent = "Failed to fetch session token or call backend: " + e;
        }
      })();
    })();
  </script>
</body>
</html>
HTML;
    exit;
}
```

Notes:

* The **`host`** URL param must be passed into App Bridge.
* Using `getSessionToken(app)` is the canonical way to obtain a session token; Shopify‚Äôs docs show this exact pattern. In newer App Bridge versions, auth can be auto-injected into `fetch`, but `getSessionToken` remains the explicit, portable approach. ([Shopify][5], [Shopify Developer Community Forums][6])

---

### 3) Backend: verify the session token on API routes

Add an `/api/ping` route that:

* reads `Authorization: Bearer <token>`
* verifies the JWT using your **API secret**
* extracts the `dest/iss/aud/sub/exp` claims
* proceeds only if valid, then uses your existing Shopify REST client

```php
use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Shopify\Clients\Rest;

if ($path === '/api/ping') {
    $shop = sanitizeShop($_GET['shop'] ?? '') ?? fail('Missing shop.');
    setCsp($shop);

    // 1) Read the token from the Authorization header
    $auth = $_SERVER['HTTP_AUTHORIZATION'] ?? '';
    if (!preg_match('/^Bearer\s+(.+)$/i', $auth, $m)) {
        fail('Missing Bearer token');
    }
    $token = $m[1];

    // 2) Verify the JWT (HS256 with your app secret)
    try {
        $decoded = JWT::decode($token, new Key(SHOPIFY_API_SECRET, 'HS256'));
        // Minimal checks:
        // - aud must equal your API key
        // - iss/dest must match this shop
        // - token not expired (library checks `exp` by default)
        if (($decoded->aud ?? null) !== SHOPIFY_API_KEY) fail('Bad audience');
        $iss = (string)($decoded->iss ?? '');
        if (stripos($iss, $shop) === false) fail('Issuer/shop mismatch');
    } catch (Throwable $e) {
        fail('Invalid session token: ' . $e->getMessage());
    }

    // 3) Load an offline session and call the Admin API via official client
    //    (After your OAuth step, a stored session exists for this shop.)
    $client = new Rest($shop, /* access token */ null);
    // If you‚Äôve switched fully to the library‚Äôs SessionStorage, you can fetch the token like this:
    //   $req = makeLibraryRequest();
    //   $session = Shopify\Utils::loadCurrentSession($req['headers'], $req['cookies'], false);
    //   $client = new Rest($session->getShop(), $session->getAccessToken());

    // For demo, hit /shop.json
    $resp = $client->get('shop');
    header('Content-Type: application/json');
    echo json_encode([
        'ok' => true,
        'shop' => $resp->getDecodedBody(),
        'token_claims' => [
            'aud' => $decoded->aud ?? null,
            'iss' => $decoded->iss ?? null,
            'dest' => $decoded->dest ?? null,
            'sub' => $decoded->sub ?? null,
            'exp' => $decoded->exp ?? null,
        ],
    ], JSON_PRETTY_PRINT);
    exit;
}
```

Why this is correct:

* **Frontend:** App Bridge issues a session token via `getSessionToken(app)` and you attach it to requests. ([Shopify][5])
* **Backend:** Session tokens are JWTs signed with your app secret; decode & verify (HS256). Check `aud` (must be your API key), `iss/dest` (shop context), and expiry. Shopify‚Äôs session-token pages outline this flow. ([Shopify][1])

---

### 4) Keep OAuth as-is (from the prior step)

Your `/install` and `/auth/callback` using the library are unchanged. Session tokens **don‚Äôt replace** OAuth; you still store the Admin API access token for server‚ÜíShopify calls. Session tokens just prove an **embedded** browser request is legit. ([Shopify][1])

---

### Quick test

1. Start your server: `php -S localhost:8080`
2. Install the app (as before).
3. Open the app from the **Shopify Admin** (so it loads in an iframe with `host`/`shop` params).
4. You should see JSON from `/api/ping` with `shop` info and decoded token claims.

---

### Optional tweaks

* **Auto-refresh tokens:** session tokens last \~1 minute; call `getSessionToken(app)` before each backend request. ([Shopify][1])
* **Security headers:** keep CSP; add standard `X-Frame-Options` **not** set (CSP supersedes it).
* **Newer App Bridge behavior:** some versions auto-inject auth into `fetch`. Using `getSessionToken` explicitly keeps the flow clear and works across versions. ([Shopify Developer Community Forums][6])

[1]: https://shopify.dev/docs/apps/build/authentication-authorization/session-tokens?utm_source=chatgpt.com "About session tokens - Shopify Developers Platform"
[2]: https://shopify.dev/docs/apps/build/security/set-up-iframe-protection?utm_source=chatgpt.com "Set up iframe protection - Shopify Developers Platform"
[3]: https://dev.to/commonninja/fixing-frame-ancestors-directive-errors-on-shopify-embedded-apps-3afg?utm_source=chatgpt.com "Fixing \"frame-ancestors directive\" Errors on Shopify Embedded Apps"
[4]: https://community.shopify.com/t/frame-ancestors-violation-in-embedded-app/243772?utm_source=chatgpt.com "Frame ancestors violation in embedded app - Shopify Community"
[5]: https://shopify.dev/docs/apps/build/authentication-authorization/session-tokens/set-up-session-tokens?utm_source=chatgpt.com "Set up session tokens - Shopify Developers Platform"
[6]: https://community.shopify.dev/t/shopify-app-not-authenticating-using-session-tokens/5885?utm_source=chatgpt.com "Shopify app not authenticating using session tokens - App Bridge ..."

---

## Add A Tiny React/Polaris Embedded UI

Here‚Äôs a **tiny embedded React + Polaris UI** that runs inside Shopify Admin, uses **App Bridge** to get a **session token**, and calls your PHP backend.

It adds:

* a new `GET /app` route that serves a minimal React+Polaris page
* a new `GET /api/shop` route that verifies the session token and returns `/shop.json`

You can drop these into your existing `index.php` from earlier.

---

### 1) Add `/api/shop` (backend JSON)

Place this **above** your `404` block:

```php
use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Shopify\Clients\Rest;

if ($path === '/api/shop') {
    $shop = sanitizeShop($_GET['shop'] ?? '') ?? fail('Missing shop.');
    setCsp($shop);

    // Read & verify Bearer token (session token from App Bridge)
    $auth = $_SERVER['HTTP_AUTHORIZATION'] ?? '';
    if (!preg_match('/^Bearer\s+(.+)$/i', $auth, $m)) fail('Missing Bearer token');
    $token = $m[1];

    try {
        $decoded = JWT::decode($token, new Key(SHOPIFY_API_SECRET, 'HS256'));
        if (($decoded->aud ?? null) !== SHOPIFY_API_KEY) fail('Bad audience');
        $iss = (string)($decoded->iss ?? '');
        if (stripos($iss, $shop) === false) fail('Issuer/shop mismatch');
    } catch (Throwable $e) {
        fail('Invalid session token: ' . $e->getMessage());
    }

    // Use the official REST client with your stored (offline) session
    // If you already load the Session via Utils::loadCurrentSession, use that token.
    $client = new Rest($shop, null);
    // If needed, load the stored session like this:
    // $req = makeLibraryRequest();
    // $session = Shopify\Utils::loadCurrentSession($req['headers'], $req['cookies'], false);
    // $client = new Rest($session->getShop(), $session->getAccessToken());

    $resp = $client->get('shop');
    header('Content-Type: application/json');
    echo json_encode($resp->getDecodedBody(), JSON_PRETTY_PRINT);
    exit;
}
```

---

### 2) Replace `/` with a redirect into the embedded UI

Replace your current home (`/`) route with this small helper that nudges users into the embedded page if they arrive from Admin:

```php
if ($path === '/') {
    // If Shopify loaded us in an iframe, we‚Äôll get host & shop in the URL.
    $shop = sanitizeShop($_GET['shop'] ?? '') ?? '';
    $host = $_GET['host'] ?? '';
    if ($shop && $host) {
        header('Location: /app?shop=' . urlencode($shop) . '&host=' . urlencode($host), true, 302);
        exit;
    }
    // Fallback: simple install form (non-embedded entry)
    echo "<h1>Shopify PHP Minimal</h1>";
    echo "<p>Install the app into a store:</p>";
    echo '<form method="GET" action="/install">
            <input name="shop" placeholder="storename.myshopify.com" required />
            <button type="submit">Install</button>
          </form>';
    exit;
}
```

---

### 3) Add `/app` (serves a build-less React + Polaris page)

This is a **single-file** UI (no bundler) using ESM CDN imports. Paste this route above your `404`:

```php
if ($path === '/app') {
    $shop = sanitizeShop($_GET['shop'] ?? '') ?? '';
    $host = $_GET['host'] ?? '';
    if (!$shop || !$host) fail('Missing shop or host.');
    setCsp($shop);

    $apiKey = SHOPIFY_API_KEY;
    $hostEsc = htmlspecialchars($host, ENT_QUOTES);
    $shopEsc = htmlspecialchars($shop, ENT_QUOTES);

    echo <<<HTML
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Shopify PHP Minimal ‚Äî Embedded</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Polaris styles -->
  <link rel="stylesheet" href="https://unpkg.com/@shopify/polaris@12.11.0/build/esm/styles.css">
  <style>html,body,#root{height:100%;margin:0}</style>
</head>
<body>
  <div id="root"></div>

  <!-- App Bridge (CDN) -->
  <script src="https://unpkg.com/@shopify/app-bridge"></script>
  <script src="https://unpkg.com/@shopify/app-bridge/utilities"></script>

  <!-- Build-less React + Polaris via ESM -->
  <script type="module">
    import React, {useEffect, useState} from "https://esm.sh/react@18";
    import {createRoot} from "https://esm.sh/react-dom@18/client";
    import {
      AppProvider,
      Page,
      Card,
      Text,
      InlineStack,
      Box,
      Button
    } from "https://esm.sh/@shopify/polaris@12.11.0";

    const apiKey = "{$apiKey}";
    const host = "{$hostEsc}";
    const shop = "{$shopEsc}";

    const AppBridge = window['app-bridge'];
    const utils = window['app-bridge'].utilities || window['app-bridge-utilities'];
    const createApp = AppBridge.default;
    const getSessionToken = (utils && utils.getSessionToken) || (window['app-bridge-utils'] && window['app-bridge-utils'].getSessionToken);

    const app = createApp({ apiKey, host, forceRedirect: true });

    function useShopInfo() {
      const [state, setState] = useState({loading: true, error: null, data: null});
      const fetchData = async () => {
        try {
          const token = await getSessionToken(app);
          const res = await fetch(\`/api/shop?shop=\${encodeURIComponent(shop)}\`, {
            headers: { Authorization: "Bearer " + token }
          });
          if (!res.ok) throw new Error("HTTP " + res.status);
          const json = await res.json();
          setState({loading:false, error:null, data: json.shop});
        } catch (e) {
          setState({loading:false, error: String(e), data: null});
        }
      };
      useEffect(() => { fetchData(); }, []);
      return { ...state, refetch: fetchData };
    }

    function UI() {
      const {loading, error, data, refetch} = useShopInfo();
      return (
        <AppProvider i18n={{}}>
          <Page title="PHP + Polaris (Embedded)">
            <InlineStack gap="400" align="start" wrap={false}>
              <Box width="100%">
                <Card>
                  <Box padding="400">
                    {loading && <Text as="p" variant="bodyMd">Loading shop info‚Ä¶</Text>}
                    {error && (
                      <>
                        <Text as="p" tone="critical">Error: {error}</Text>
                        <Box paddingBlockStart="300"><Button onClick={refetch}>Retry</Button></Box>
                      </>
                    )}
                    {data && (
                      <>
                        <Text as="h2" variant="headingLg">Shop</Text>
                        <Box paddingBlockStart="200">
                          <Text as="p" variant="bodyMd"><b>Name:</b> {data.shop?.name}</Text>
                          <Text as="p" variant="bodyMd"><b>Domain:</b> {data.shop?.domain}</Text>
                          <Text as="p" variant="bodyMd"><b>Plan:</b> {data.shop?.plan_name}</Text>
                          <Text as="p" variant="bodyMd"><b>Currency:</b> {data.shop?.currency}</Text>
                        </Box>
                        <Box paddingBlockStart="300"><Button onClick={refetch}>Refresh</Button></Box>
                      </>
                    )}
                  </Box>
                </Card>
              </Box>
            </InlineStack>
          </Page>
        </AppProvider>
      );
    }

    const root = createRoot(document.getElementById("root"));
    root.render(<UI />);
  </script>
</body>
</html>
HTML;
    exit;
}
```

**What it does**

* Loads **Polaris** styles from CDN, React via ESM, and **App Bridge** from CDN.
* Creates an App Bridge instance with your **API key** and the `host` param from Admin.
* Calls `getSessionToken(app)` then hits `/api/shop` with `Authorization: Bearer <token>`.
* Renders shop info in a **Polaris** `Page`/`Card`.

---

### 4) Make sure these helpers exist

You already added `setCsp()` and `makeLibraryRequest()` earlier. Keep them. `setCsp($shop)` should set:

```php
function setCsp(?string $shopDomain = null): void {
    $ancestors = ["https://admin.shopify.com"];
    if ($shopDomain) $ancestors[] = "https://{$shopDomain}";
    header("Content-Security-Policy: frame-ancestors " . implode(' ', $ancestors));
}
```

---

### 5) Try it

1. Start server: `php -S localhost:8080`
2. Install app if you haven‚Äôt.
3. Open the app from **Shopify Admin** ‚Üí it should land on `/app?...` inside the iframe and render the Polaris page with your shop details.

---

## Removing The Legacy Token Storage

Got it. Here‚Äôs the clean swap so `/shop` reads the **library session** (offline) and you can delete `tokens/`.

---

### 1) Remove file-token usage

* Delete the `tokens/` folder.
* Remove any code that reads/writes `tokens/{shop}.json`.

---

### 2) Replace the `/shop` route

Drop this in your `index.php` (same place as before). It loads the **offline** session from the library and uses its access token.

```php
use Shopify\Utils;
use Shopify\Clients\Rest;

if ($path === '/shop') {
    $shop = sanitizeShop($_GET['shop'] ?? '') ?? fail('Missing shop.');

    // Build request shape for the library
    $req = makeLibraryRequest();

    // Load the OFFLINE session (must match isOnline=false used during OAuth begin)
    $session = Utils::loadCurrentSession($req['headers'], $req['cookies'], false);
    if (!$session) fail('No saved session. Reinstall the app.');
    if (strtolower($session->getShop()) !== strtolower($shop)) {
        fail('Session/shop mismatch.');
    }

    $accessToken = $session->getAccessToken();
    if (!$accessToken) fail('No access token in session.');

    // Official REST client
    $client = new Rest($session->getShop(), $accessToken);
    $resp = $client->get('shop');

    header('Content-Type: application/json');
    echo json_encode($resp->getDecodedBody(), JSON_PRETTY_PRINT);
    exit;
}
```

---

### 3) Sanity checks

* `Context::initialize(... isEmbeddedApp: true, ...)` already set; `FileSessionStorage(__DIR__.'/sessions')` exists and is writable.
* Your OAuth routes use `OAuth::begin(..., isOnline: false, ...)` and `OAuth::callback(...)`.
* You still use `/app` and `/api/*` as before‚Äîno changes needed there.

That‚Äôs it‚Äî`/shop` now uses the official session storage.

---

## Adding A Products Table

Great‚Äîhere‚Äôs a small **Products table** that:

* adds `GET /api/products` on the backend (uses the official PHP client)
* renders a **Polaris IndexTable** in your embedded React page
* supports cursor pagination (`page_info`) and minimal fields

> Make sure your app requests the **`read_products`** scope.

---

### 1) Backend: `GET /api/products`

Add this route **above** your 404 in `index.php` (similar to `/api/shop`).
It verifies the session token, loads your offline session via the library, and returns products with cursor pagination.

```php
use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Shopify\Utils;
use Shopify\Clients\Rest;

if ($path === '/api/products') {
    $shop = sanitizeShop($_GET['shop'] ?? '') ?? fail('Missing shop.');
    setCsp($shop);

    // Bearer session token (from App Bridge)
    $auth = $_SERVER['HTTP_AUTHORIZATION'] ?? '';
    if (!preg_match('/^Bearer\s+(.+)$/i', $auth, $m)) fail('Missing Bearer token');
    $token = $m[1];

    try {
        $decoded = JWT::decode($token, new Key(SHOPIFY_API_SECRET, 'HS256'));
        if (($decoded->aud ?? null) !== SHOPIFY_API_KEY) fail('Bad audience');
        $iss = (string)($decoded->iss ?? '');
        if (stripos($iss, $shop) === false) fail('Issuer/shop mismatch');
    } catch (Throwable $e) {
        fail('Invalid session token: ' . $e->getMessage());
    }

    // Load OFFLINE session via library (matches isOnline=false in OAuth)
    $req = makeLibraryRequest();
    $session = Utils::loadCurrentSession($req['headers'], $req['cookies'], false);
    if (!$session || strtolower($session->getShop()) !== strtolower($shop)) {
        fail('No valid offline session for this shop. Reinstall.');
    }

    $client = new Rest($session->getShop(), $session->getAccessToken());

    // Cursor pagination
    $limit = max(1, min((int)($_GET['limit'] ?? 25), 50));
    $pageInfo = $_GET['page_info'] ?? null;

    $query = [
        'limit'  => $limit,
        'fields' => 'id,title,status,handle,created_at,variants',
    ];
    if ($pageInfo) $query['page_info'] = $pageInfo;

    $resp = $client->get('products', $query);

    // Parse Link header for next/prev page_info
    $headers = $resp->getHeaders();
    $linkHeader = '';
    foreach ($headers as $k => $v) {
        if (strtolower($k) === 'link') { $linkHeader = is_array($v) ? implode(',', $v) : $v; break; }
    }
    $next = null; $prev = null;
    if ($linkHeader) {
        // Example: <...page_info=abc&limit=25>; rel="next", <...page_info=xyz&limit=25>; rel="previous"
        foreach (explode(',', $linkHeader) as $part) {
            if (preg_match('/<([^>]+)>;\s*rel="([^"]+)"/', trim($part), $m2)) {
                $url = $m2[1]; $rel = $m2[2];
                $u = parse_url($url);
                parse_str($u['query'] ?? '', $qs);
                if (!empty($qs['page_info'])) {
                    if ($rel === 'next') $next = $qs['page_info'];
                    if ($rel === 'previous') $prev = $qs['page_info'];
                }
            }
        }
    }

    header('Content-Type: application/json');
    echo json_encode([
        'products' => $resp->getDecodedBody()['products'] ?? [],
        'page_info' => [
            'next' => $next,
            'prev' => $prev,
            'limit' => $limit,
        ],
    ], JSON_PRETTY_PRINT);
    exit;
}
```

---

### 2) Frontend: add a Products table to `/app`

In your `/app` route‚Äôs `<script type="module">`, add a simple hook to fetch products and a **Polaris IndexTable** to render them. You can keep the existing ‚ÄúShop‚Äù card. Below is a drop-in that adds a second card called ‚ÄúProducts‚Äù.

#### 2a) Add imports

In the `import` block from `@shopify/polaris`, include `IndexTable`, `TextField`, and `Pagination`:

```js
import {
  AppProvider,
  Page,
  Card,
  Text,
  InlineStack,
  Box,
  Button,
  IndexTable,
  TextField,
  Pagination
} from "https://esm.sh/@shopify/polaris@12.11.0";
```

#### 2b) Add a hook to fetch products

Place this alongside your `useShopInfo()`:

```js
function useProducts(app, shop) {
  const [state, setState] = React.useState({
    loading: true,
    error: null,
    items: [],
    pageInfo: { next: null, prev: null, limit: 25 }
  });

  const fetchPage = async (pageInfo = null) => {
    try {
      const token = await getSessionToken(app);
      const qs = new URLSearchParams({ shop, limit: String(state.pageInfo.limit) });
      if (pageInfo) qs.set('page_info', pageInfo);
      const res = await fetch(`/api/products?` + qs.toString(), {
        headers: { Authorization: "Bearer " + token }
      });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const json = await res.json();
      setState({
        loading: false,
        error: null,
        items: json.products || [],
        pageInfo: json.page_info || { next: null, prev: null, limit: 25 }
      });
    } catch (e) {
      setState(s => ({ ...s, loading:false, error:String(e) }));
    }
  };

  React.useEffect(() => { fetchPage(); }, []);
  return {
    ...state,
    next: () => state.pageInfo.next ? fetchPage(state.pageInfo.next) : null,
    prev: () => state.pageInfo.prev ? fetchPage(state.pageInfo.prev) : null,
    setLimit: (n) => setState(s => ({ ...s, pageInfo: { ...s.pageInfo, limit: n } }))
  };
}
```

#### 2c) Add a `ProductsCard` component

Place this below your `UI` or just embed inside it‚Äîshown here as a component for clarity:

```js
function ProductsCard({app, shop}) {
  const {loading, error, items, pageInfo, next, prev, setLimit} = useProducts(app, shop);
  const [limitStr, setLimitStr] = React.useState(String(pageInfo.limit || 25));

  const rows = (items || []).map((p) => {
    const variant = (p.variants && p.variants[0]) || {};
    const price = variant.price ? `$${variant.price}` : '‚Äî';
    const inv   = (variant.inventory_quantity ?? '‚Äî');
    return {
      id: String(p.id),
      title: p.title || '(untitled)',
      status: p.status || '‚Äî',
      price,
      inv
    };
  });

  const resourceName = { singular: 'product', plural: 'products' };

  return (
    <Card>
      <Box padding="400">
        <InlineStack gap="400" align="space-between">
          <Text as="h2" variant="headingLg">Products</Text>
          <InlineStack gap="200" align="center">
            <Text as="span" variant="bodyMd">Per page:</Text>
            <TextField
              label="Limit"
              labelHidden
              value={limitStr}
              onChange={(v)=>setLimitStr(v)}
              onBlur={()=>{ const n = Math.max(1, Math.min(parseInt(limitStr||'25',10)||25, 50)); setLimit(n); }}
              autoComplete="off"
              inputMode="numeric"
              type="text"
              maxLength={2}
            />
            <Button onClick={()=>{ const n = Math.max(1, Math.min(parseInt(limitStr||'25',10)||25, 50)); setLimit(n); }}>Set</Button>
          </InlineStack>
        </InlineStack>

        {loading && <Box paddingBlockStart="300"><Text as="p">Loading products‚Ä¶</Text></Box>}
        {error && (
          <Box paddingBlockStart="300">
            <Text as="p" tone="critical">Error: {error}</Text>
            <Box paddingBlockStart="200"><Button onClick={()=>window.location.reload()}>Reload</Button></Box>
          </Box>
        )}

        {!loading && !error && (
          <>
            <IndexTable
              resourceName={resourceName}
              itemCount={rows.length}
              headings={[
                {title: 'Title'},
                {title: 'Status'},
                {title: 'Price (1st variant)'},
                {title: 'Inventory (1st variant)'}
              ]}
              selectable={false}
            >
              {rows.map((r, idx) => (
                <IndexTable.Row id={r.id} key={r.id} position={idx}>
                  <IndexTable.Cell><Text as="span" variant="bodyMd">{r.title}</Text></IndexTable.Cell>
                  <IndexTable.Cell>{r.status}</IndexTable.Cell>
                  <IndexTable.Cell>{r.price}</IndexTable.Cell>
                  <IndexTable.Cell>{r.inv}</IndexTable.Cell>
                </IndexTable.Row>
              ))}
            </IndexTable>

            <Box paddingBlockStart="300">
              <Pagination
                hasPrevious={!!pageInfo.prev}
                onPrevious={prev || (()=>{})}
                hasNext={!!pageInfo.next}
                onNext={next || (()=>{})}
              />
            </Box>
          </>
        )}
      </Box>
    </Card>
  );
}
```

#### 2d) Render it in your main `UI`

In your existing `UI()` component (where you already show the Shop card), add the Products card below it:

```js
function UI() {
  const {loading, error, data, refetch} = useShopInfo();
  return (
    <AppProvider i18n={{}}>
      <Page title="PHP + Polaris (Embedded)">
        <InlineStack gap="400" align="start" wrap={false}>
          <Box width="100%">
            {/* Existing Shop card */}
            <Card>
              <Box padding="400">
                {loading && <Text as="p" variant="bodyMd">Loading shop info‚Ä¶</Text>}
                {error && (
                  <>
                    <Text as="p" tone="critical">Error: {error}</Text>
                    <Box paddingBlockStart="300"><Button onClick={refetch}>Retry</Button></Box>
                  </>
                )}
                {data && (
                  <>
                    <Text as="h2" variant="headingLg">Shop</Text>
                    <Box paddingBlockStart="200">
                      <Text as="p" variant="bodyMd"><b>Name:</b> {data.shop?.name}</Text>
                      <Text as="p" variant="bodyMd"><b>Domain:</b> {data.shop?.domain}</Text>
                      <Text as="p" variant="bodyMd"><b>Plan:</b> {data.shop?.plan_name}</Text>
                      <Text as="p" variant="bodyMd"><b>Currency:</b> {data.shop?.currency}</Text>
                    </Box>
                  </>
                )}
              </Box>
            </Card>

            {/* New Products table */}
            <Box paddingBlockStart="400">
              <ProductsCard app={app} shop={shop} />
            </Box>
          </Box>
        </InlineStack>
      </Page>
    </AppProvider>
  );
}
```

---

### 3) That‚Äôs it

* Backend: `/api/products` with cursor pagination and minimal fields
* Frontend: `IndexTable` with next/prev + adjustable page size (1‚Äì50)
* Scope: ensure `read_products` is granted in the app setup

---

## Switching To GraphQL

We‚Äôll switch your products endpoint to **GraphQL Admin API** (fewer roundtrips, custom fields), and tweak the frontend to use GraphQL-style cursors.

Below are **surgical edits** only‚Äîdrop them into your existing setup.

---

### 1) Backend: GraphQL `GET /api/products`

Add/replace this route (above your 404). It:

* verifies the **session token** (same as before),
* loads your **offline** session via the library,
* runs a **GraphQL** query with cursor pagination,
* returns a compact JSON payload for the UI.

```php
use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Shopify\Utils;
use Shopify\Clients\Graphql;

if ($path === '/api/products') {
    $shop = sanitizeShop($_GET['shop'] ?? '') ?? fail('Missing shop.');
    setCsp($shop);

    // Session token from App Bridge
    $auth = $_SERVER['HTTP_AUTHORIZATION'] ?? '';
    if (!preg_match('/^Bearer\s+(.+)$/i', $auth, $m)) fail('Missing Bearer token');
    $token = $m[1];

    try {
        $decoded = JWT::decode($token, new Key(SHOPIFY_API_SECRET, 'HS256'));
        if (($decoded->aud ?? null) !== SHOPIFY_API_KEY) fail('Bad audience');
        $iss = (string)($decoded->iss ?? '');
        if (stripos($iss, $shop) === false) fail('Issuer/shop mismatch');
    } catch (Throwable $e) {
        fail('Invalid session token: ' . $e->getMessage());
    }

    // Load OFFLINE session (isOnline=false)
    $req = makeLibraryRequest();
    $session = Utils::loadCurrentSession($req['headers'], $req['cookies'], false);
    if (!$session || strtolower($session->getShop()) !== strtolower($shop)) {
        fail('No valid offline session for this shop. Reinstall.');
    }

    $limit  = max(1, min((int)($_GET['limit'] ?? 25), 50));
    $after  = $_GET['cursor'] ?? null;        // GraphQL "after" cursor
    $queryQ = trim((string)($_GET['q'] ?? '')); // optional search string

    // Build GraphQL
    $gql = <<<'GQL'
query Products($first: Int!, $after: String, $query: String) {
  products(first: $first, after: $after, query: $query, sortKey: CREATED_AT, reverse: true) {
    edges {
      cursor
      node {
        id
        title
        status
        handle
        createdAt
        totalInventory
        variants(first: 1) {
          edges {
            node {
              id
              price { amount currencyCode }
              inventoryQuantity
            }
          }
        }
      }
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      endCursor
      startCursor
    }
  }
}
GQL;

    $client = new Graphql($session->getShop(), $session->getAccessToken());
    $resp = $client->query([
        'query' => $gql,
        'variables' => [
            'first' => $limit,
            'after' => $after ?: null,
            'query' => ($queryQ !== '' ? $queryQ : null),
        ],
    ]);

    $data = $resp->getDecodedBody()['data']['products'] ?? ['edges'=>[], 'pageInfo'=>[]];

    // Flatten for UI
    $items = [];
    foreach ($data['edges'] as $edge) {
        $n = $edge['node'];
        $v = $n['variants']['edges'][0]['node'] ?? null;
        $price = $v && isset($v['price'])
            ? $v['price']['amount'] . ' ' . $v['price']['currencyCode']
            : '‚Äî';
        $inv = $v['inventoryQuantity'] ?? '‚Äî';

        $items[] = [
            'id' => $n['id'],
            'title' => $n['title'] ?: '(untitled)',
            'status' => $n['status'] ?? '‚Äî',
            'handle' => $n['handle'] ?? '‚Äî',
            'createdAt' => $n['createdAt'] ?? null,
            'price' => $price,
            'inv' => $inv,
            'cursor' => $edge['cursor'] ?? null,
        ];
    }

    header('Content-Type: application/json');
    echo json_encode([
        'products' => $items,
        'page_info' => [
            'has_next' => $data['pageInfo']['hasNextPage'] ?? false,
            'has_prev' => $data['pageInfo']['hasPreviousPage'] ?? false,
            'end_cursor' => $data['pageInfo']['endCursor'] ?? null,
            'start_cursor' => $data['pageInfo']['startCursor'] ?? null,
            'limit' => $limit,
        ],
    ], JSON_PRETTY_PRINT);
    exit;
}
```

> Want more fields? Add them in the GraphQL `node { ... }` selection and pass them through in `$items`.

---

### 2) Frontend: adapt to GraphQL cursors

Update your build-less React page inside `/app`:

#### 2a) Keep your imports; no new ones needed.

#### 2b) Replace your `useProducts` hook with GraphQL-aware version

```js
function useProducts(app, shop) {
  const [state, setState] = React.useState({
    loading: true,
    error: null,
    items: [],
    pageInfo: { has_next: false, has_prev: false, end_cursor: null, start_cursor: null, limit: 25 },
    // Maintain a small cursor stack for "Previous" since GraphQL doesn't hand us a prev cursor directly
    cursorStack: []  // stack of previous end_cursors
  });

  const fetchPage = async (cursor = null, pushStack = false) => {
    try {
      const token = await getSessionToken(app);
      const qs = new URLSearchParams({ shop, limit: String(state.pageInfo.limit) });
      if (cursor) qs.set('cursor', cursor);
      const res = await fetch(`/api/products?` + qs.toString(), {
        headers: { Authorization: "Bearer " + token }
      });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const json = await res.json();

      setState(s => ({
        loading: false,
        error: null,
        items: json.products || [],
        pageInfo: json.page_info || s.pageInfo,
        cursorStack: pushStack && s.pageInfo.end_cursor ? [...s.cursorStack, s.pageInfo.end_cursor] : s.cursorStack
      }));
    } catch (e) {
      setState(s => ({ ...s, loading:false, error:String(e) }));
    }
  };

  // next: go to end_cursor; prev: pop stack and refetch from popped cursor's predecessor
  const next = () => state.pageInfo.has_next && fetchPage(state.pageInfo.end_cursor, true);
  const prev = () => {
    if (!state.cursorStack.length) return;
    const stack = state.cursorStack.slice(0, -1);
    const target = stack[stack.length - 1] || null; // one step back
    setState(s => ({ ...s, cursorStack: stack, loading: true }));
    fetchPage(target, false);
  };

  React.useEffect(() => { fetchPage(null, false); }, []);

  return {
    ...state,
    next,
    prev,
    setLimit: (n) => setState(s => ({ ...s, pageInfo: { ...s.pageInfo, limit: n } }))
  };
}
```

#### 2c) The `ProductsCard` component works unchanged

It already renders from `items` and calls `next` / `prev`.
(Optional: show `createdAt` or `handle`‚Äîthey‚Äôre in each item now.)

Example of adding a column (replace headings/rows accordingly):

```js
// headings:
{title: 'Handle'}, {title: 'Created'}

// row mapping:
const rows = (items || []).map((p) => ({
  id: p.id,
  title: p.title,
  status: p.status,
  price: p.price,
  inv: p.inv,
  handle: p.handle,
  created: p.createdAt ? new Date(p.createdAt).toLocaleString() : '‚Äî'
}));
```

---

### 3) Optional: search/filter

Since we added a `$query` variable, you can wire a search box that calls:

```
/api/products?shop=...&q=title:*hat* status:active
```

Shopify‚Äôs Admin search syntax supports fields like `title:`, `status:`, etc. Keep it simple:

* add a `TextField` bound to `q`,
* include `q` in the query string in `fetchPage`.

---

### 4) Summary

* Backend now uses **GraphQL** (`Shopify\Clients\Graphql`) with a single query for everything you render.
* UI keeps the same table, just reads GraphQL pagination.
* Add fields by editing the GraphQL selection‚Äîno extra requests.

---

## Adding A Product Detail Drawer

Here‚Äôs a clean **Product detail drawer** using GraphQL.

It adds:

* `GET /api/product?id=...` (backend)
* a **Polaris Modal** that opens from the table (frontend)

> Prereq: you already have `read_products` scope and the GraphQL client in place.

---

### 1) Backend: `GET /api/product`

Add this route above your 404. It reuses your session-token verification and offline session load.

```php
use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Shopify\Utils;
use Shopify\Clients\Graphql;

if ($path === '/api/product') {
    $shop = sanitizeShop($_GET['shop'] ?? '') ?? fail('Missing shop.');
    $id   = $_GET['id'] ?? null; // expects a GraphQL gid: "gid://shopify/Product/1234567890"
    if (!$id) fail('Missing product id.');
    setCsp($shop);

    // Verify session token (Bearer)
    $auth = $_SERVER['HTTP_AUTHORIZATION'] ?? '';
    if (!preg_match('/^Bearer\s+(.+)$/i', $auth, $m)) fail('Missing Bearer token');
    $token = $m[1];
    try {
        $decoded = JWT::decode($token, new Key(SHOPIFY_API_SECRET, 'HS256'));
        if (($decoded->aud ?? null) !== SHOPIFY_API_KEY) fail('Bad audience');
        $iss = (string)($decoded->iss ?? '');
        if (stripos($iss, $shop) === false) fail('Issuer/shop mismatch');
    } catch (Throwable $e) {
        fail('Invalid session token: ' . $e->getMessage());
    }

    // Load OFFLINE session
    $req = makeLibraryRequest();
    $session = Utils::loadCurrentSession($req['headers'], $req['cookies'], false);
    if (!$session || strtolower($session->getShop()) !== strtolower($shop)) {
        fail('No valid offline session for this shop. Reinstall.');
    }

    // GraphQL: product by id (images + variants)
    $gql = <<<'GQL'
query Product($id: ID!) {
  product(id: $id) {
    id
    title
    handle
    descriptionHtml
    vendor
    productType
    status
    createdAt
    updatedAt
    featuredImage { url altText }
    images(first: 8) {
      edges { node { id url altText } }
    }
    variants(first: 25) {
      edges {
        node {
          id
          title
          sku
          inventoryQuantity
          price { amount currencyCode }
          compareAtPrice { amount currencyCode }
        }
      }
    }
  }
}
GQL;

    $client = new Graphql($session->getShop(), $session->getAccessToken());
    $resp = $client->query([
        'query' => $gql,
        'variables' => ['id' => $id],
    ]);

    header('Content-Type: application/json');
    echo json_encode($resp->getDecodedBody()['data']['product'] ?? null, JSON_PRETTY_PRINT);
    exit;
}
```

---

### 2) Frontend: add a ‚ÄúView‚Äù action + Modal

In your `/app` page‚Äôs `<script type="module">`, update the UI.

#### 2a) Add imports

Extend your Polaris import list:

```js
import {
  AppProvider, Page, Card, Text, InlineStack, Box, Button,
  IndexTable, TextField, Pagination, Modal, Thumbnail, Badge, Divider
} from "https://esm.sh/@shopify/polaris@12.11.0";
```

#### 2b) Add product-detail state + fetcher

Place these near the top of the module (alongside other helpers):

```js
function useSessionToken(app) {
  return async () => await getSessionToken(app);
}

async function fetchProductDetail(app, shop, id) {
  const token = await getSessionToken(app);
  const qs = new URLSearchParams({ shop, id });
  const res = await fetch(`/api/product?` + qs.toString(), {
    headers: { Authorization: "Bearer " + token }
  });
  if (!res.ok) throw new Error("HTTP " + res.status);
  return await res.json();
}
```

#### 2c) Update `ProductsCard` to include a ‚ÄúView‚Äù column and the Modal

Replace your existing `ProductsCard` with this version (keeps pagination, adds a details modal):

```js
function ProductsCard({app, shop}) {
  const {loading, error, items, pageInfo, next, prev, setLimit} = useProducts(app, shop);
  const [limitStr, setLimitStr] = React.useState(String(pageInfo.limit || 25));

  const [detailOpen, setDetailOpen] = React.useState(false);
  const [detailLoading, setDetailLoading] = React.useState(false);
  const [detailError, setDetailError] = React.useState(null);
  const [product, setProduct] = React.useState(null);

  const openDetail = async (id) => {
    setDetailOpen(true);
    setDetailLoading(true);
    setDetailError(null);
    try {
      const p = await fetchProductDetail(app, shop, id);
      setProduct(p);
    } catch (e) {
      setDetailError(String(e));
    } finally {
      setDetailLoading(false);
    }
  };

  const closeDetail = () => {
    setDetailOpen(false);
    setProduct(null);
    setDetailError(null);
  };

  const rows = (items || []).map((p) => {
    return {
      id: p.id,
      title: p.title || '(untitled)',
      status: p.status || '‚Äî',
      price: p.price || '‚Äî',
      inv: p.inv ?? '‚Äî',
    };
  });

  const resourceName = { singular: 'product', plural: 'products' };

  return (
    <>
      <Card>
        <Box padding="400">
          <InlineStack gap="400" align="space-between">
            <Text as="h2" variant="headingLg">Products</Text>
            <InlineStack gap="200" align="center">
              <Text as="span" variant="bodyMd">Per page:</Text>
              <TextField
                label="Limit"
                labelHidden
                value={limitStr}
                onChange={(v)=>setLimitStr(v)}
                onBlur={()=>{ const n = Math.max(1, Math.min(parseInt(limitStr||'25',10)||25, 50)); setLimit(n); }}
                autoComplete="off"
                inputMode="numeric"
                type="text"
                maxLength={2}
              />
              <Button onClick={()=>{ const n = Math.max(1, Math.min(parseInt(limitStr||'25',10)||25, 50)); setLimit(n); }}>Set</Button>
            </InlineStack>
          </InlineStack>

          {loading && <Box paddingBlockStart="300"><Text as="p">Loading products‚Ä¶</Text></Box>}
          {error && (
            <Box paddingBlockStart="300">
              <Text as="p" tone="critical">Error: {error}</Text>
              <Box paddingBlockStart="200"><Button onClick={()=>window.location.reload()}>Reload</Button></Box>
            </Box>
          )}

          {!loading && !error && (
            <>
              <IndexTable
                resourceName={resourceName}
                itemCount={rows.length}
                headings={[
                  {title: 'Title'},
                  {title: 'Status'},
                  {title: 'Price (1st variant)'},
                  {title: 'Inventory (1st variant)'},
                  {title: 'Actions'}
                ]}
                selectable={false}
              >
                {rows.map((r, idx) => (
                  <IndexTable.Row id={r.id} key={r.id} position={idx}>
                    <IndexTable.Cell><Text as="span" variant="bodyMd">{r.title}</Text></IndexTable.Cell>
                    <IndexTable.Cell>{r.status}</IndexTable.Cell>
                    <IndexTable.Cell>{r.price}</IndexTable.Cell>
                    <IndexTable.Cell>{r.inv}</IndexTable.Cell>
                    <IndexTable.Cell>
                      <Button onClick={()=>openDetail(r.id)}>View</Button>
                    </IndexTable.Cell>
                  </IndexTable.Row>
                ))}
              </IndexTable>

              <Box paddingBlockStart="300">
                <Pagination
                  hasPrevious={!!pageInfo.has_prev}
                  onPrevious={prev || (()=>{})}
                  hasNext={!!pageInfo.has_next}
                  onNext={next || (()=>{})}
                />
              </Box>
            </>
          )}
        </Box>
      </Card>

      <Modal
        open={detailOpen}
        onClose={closeDetail}
        title={product?.title || 'Product details'}
        primaryAction={{ content: 'Close', onAction: closeDetail }}
      >
        <Modal.Section>
          {detailLoading && <Text as="p">Loading‚Ä¶</Text>}
          {detailError && <Text as="p" tone="critical">Error: {detailError}</Text>}
          {!detailLoading && !detailError && product && (
            <Box>
              {/* Header */}
              <InlineStack gap="400" align="start">
                <Thumbnail
                  size="large"
                  source={product.featuredImage?.url || undefined}
                  alt={product.featuredImage?.altText || 'Image'}
                />
                <Box>
                  <Text as="h3" variant="headingMd">{product.title}</Text>
                  <InlineStack gap="200" align="start">
                    <Badge tone="attention">{product.status}</Badge>
                    {product.vendor && <Badge>{product.vendor}</Badge>}
                    {product.productType && <Badge>{product.productType}</Badge>}
                  </InlineStack>
                  <Text as="p" variant="bodySm">Handle: {product.handle}</Text>
                  <Text as="p" variant="bodySm">Updated: {product.updatedAt ? new Date(product.updatedAt).toLocaleString() : '‚Äî'}</Text>
                </Box>
              </InlineStack>

              <Box paddingBlockStart="300">
                <Divider />
              </Box>

              {/* Description */}
              <Box paddingBlockStart="300">
                <Text as="h4" variant="headingSm">Description</Text>
                <div style="margin-top:8px" dangerouslySetInnerHTML={{__html: product.descriptionHtml || '<em>No description</em>'}}></div>
              </Box>

              {/* Images */}
              {product.images?.edges?.length ? (
                <Box paddingBlockStart="300">
                  <Text as="h4" variant="headingSm">Images</Text>
                  <InlineStack gap="200" align="start" wrap>
                    {product.images.edges.map(e => (
                      <Thumbnail key={e.node.id} size="large" source={e.node.url} alt={e.node.altText || 'Image'} />
                    ))}
                  </InlineStack>
                </Box>
              ) : null}

              {/* Variants */}
              <Box paddingBlockStart="300">
                <Text as="h4" variant="headingSm">Variants</Text>
                {product.variants?.edges?.length ? (
                  <Box paddingBlockStart="200">
                    {product.variants.edges.map(v => {
                      const n = v.node;
                      const price = n.price ? `${n.price.amount} ${n.price.currencyCode}` : '‚Äî';
                      const cmp = n.compareAtPrice ? `${n.compareAtPrice.amount} ${n.compareAtPrice.currencyCode}` : null;
                      return (
                        <Box key={n.id} paddingBlockEnd="200">
                          <Text as="p" variant="bodyMd"><b>{n.title || '(variant)'}</b> ‚Äî SKU: {n.sku || '‚Äî'}</Text>
                          <Text as="p" variant="bodySm">Price: {price}{cmp ? `  (Compare at: ${cmp})` : ''}</Text>
                          <Text as="p" variant="bodySm">Inventory: {n.inventoryQuantity ?? '‚Äî'}</Text>
                        </Box>
                      );
                    })}
                  </Box>
                ) : <Text as="p" variant="bodyMd">No variants</Text>}
              </Box>
            </Box>
          )}
        </Modal.Section>
      </Modal>
    </>
  );
}
```

That‚Äôs it:

* Click **View** ‚Üí Modal loads full product details via `/api/product`.
* Images, variants, description, and metadata render cleanly.
* All calls are **GraphQL**, **token-verified**, and use the **offline session**.

---

## Adding A Search Box

Let‚Äôs add a **search box** (with optional status filter) that feeds your GraphQL `$query` param. Your backend `/api/products` already supports `q=...`, so this is all **frontend**.

---

### 1) Add UI controls (search + status)

In your `/app` route‚Äôs `<script type="module">`, update imports to include `Select`:

```js
import {
  AppProvider, Page, Card, Text, InlineStack, Box, Button,
  IndexTable, TextField, Pagination, Modal, Thumbnail, Badge, Divider, Select
} from "https://esm.sh/@shopify/polaris@12.11.0";
```

---

### 2) Update `useProducts` to accept `q`

Replace your `useProducts` hook with this version that:

* tracks `q` (query string),
* debounces network calls,
* includes `q` when fetching.

```js
function useProducts(app, shop) {
  const [state, setState] = React.useState({
    loading: true,
    error: null,
    items: [],
    pageInfo: { has_next: false, has_prev: false, end_cursor: null, start_cursor: null, limit: 25 },
    cursorStack: [],
    q: ''   // <-- search query
  });

  const fetchPage = async (cursor = null, pushStack = false, qOverride = null) => {
    try {
      const token = await getSessionToken(app);
      const qs = new URLSearchParams({
        shop,
        limit: String(state.pageInfo.limit),
      });
      if (cursor) qs.set('cursor', cursor);
      const qToUse = qOverride !== null ? qOverride : state.q;
      if (qToUse && qToUse.trim()) qs.set('q', qToUse.trim());

      const res = await fetch(`/api/products?` + qs.toString(), {
        headers: { Authorization: "Bearer " + token }
      });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const json = await res.json();

      setState(s => ({
        ...s,
        loading: false,
        error: null,
        items: json.products || [],
        pageInfo: json.page_info || s.pageInfo,
        cursorStack: pushStack && s.pageInfo.end_cursor ? [...s.cursorStack, s.pageInfo.end_cursor] : s.cursorStack
      }));
    } catch (e) {
      setState(s => ({ ...s, loading:false, error:String(e) }));
    }
  };

  // Debounced search trigger
  const debounceRef = React.useRef(null);
  const setQuery = (q) => {
    setState(s => ({ ...s, q, loading: true, cursorStack: [] }));
    clearTimeout(debounceRef.current);
    debounceRef.current = setTimeout(() => fetchPage(null, false, q), 300);
  };

  const next = () => state.pageInfo.has_next && fetchPage(state.pageInfo.end_cursor, true);
  const prev = () => {
    if (!state.cursorStack.length) return;
    const stack = state.cursorStack.slice(0, -1);
    const target = stack[stack.length - 1] || null;
    setState(s => ({ ...s, cursorStack: stack, loading: true }));
    fetchPage(target, false);
  };

  React.useEffect(() => { fetchPage(null, false, state.q); }, []); // initial

  return {
    ...state,
    next,
    prev,
    setLimit: (n) => setState(s => ({ ...s, pageInfo: { ...s.pageInfo, limit: n } })),
    setQuery
  };
}
```

---

### 3) Add a small ‚Äúquery builder‚Äù UI

We‚Äôll provide:

* a **search input** (free text),
* an optional **status** dropdown that appends `status:active|draft|archived` to the query,
* a small helper to combine them.

Replace your `ProductsCard` header area with this version (the rest of the component stays the same):

```js
function ProductsCard({app, shop}) {
  const {loading, error, items, pageInfo, next, prev, setLimit, setQuery, q} = useProducts(app, shop);
  const [limitStr, setLimitStr] = React.useState(String(pageInfo.limit || 25));

  // Local controls
  const [searchText, setSearchText] = React.useState('');
  const [status, setStatus] = React.useState(''); // '', 'active', 'draft', 'archived'

  // Compose Shopify Admin search syntax
  const buildQuery = React.useCallback(() => {
    const parts = [];
    if (searchText.trim()) parts.push(`title:*${searchText.trim()}*`); // fuzzy title contains
    if (status) parts.push(`status:${status}`);
    return parts.join(' ');
  }, [searchText, status]);

  const applySearch = () => setQuery(buildQuery());

  // ... keep your existing modal/detail state & handlers here ...

  const rows = (items || []).map((p) => ({
    id: p.id, title: p.title || '(untitled)', status: p.status || '‚Äî',
    price: p.price || '‚Äî', inv: p.inv ?? '‚Äî'
  }));
  const resourceName = { singular: 'product', plural: 'products' };

  return (
    <>
      <Card>
        <Box padding="400">
          <InlineStack gap="400" align="space-between" wrap>
            <Text as="h2" variant="headingLg">Products</Text>

            <InlineStack gap="200" align="center" wrap>
              <TextField
                label="Search"
                labelHidden
                placeholder="Search title‚Ä¶"
                value={searchText}
                onChange={setSearchText}
                autoComplete="off"
              />
              <Select
                label="Status"
                labelHidden
                options={[
                  {label:'Any status', value:''},
                  {label:'Active', value:'active'},
                  {label:'Draft', value:'draft'},
                  {label:'Archived', value:'archived'},
                ]}
                onChange={setStatus}
                value={status}
              />
              <Button onClick={applySearch}>Search</Button>

              <InlineStack gap="200" align="center">
                <Text as="span" variant="bodyMd">Per page:</Text>
                <TextField
                  label="Limit"
                  labelHidden
                  value={limitStr}
                  onChange={(v)=>setLimitStr(v)}
                  onBlur={()=>{ const n = Math.max(1, Math.min(parseInt(limitStr||'25',10)||25, 50)); setLimit(n); }}
                  autoComplete="off"
                  inputMode="numeric"
                  type="text"
                  maxLength={2}
                />
                <Button onClick={()=>{ const n = Math.max(1, Math.min(parseInt(limitStr||'25',10)||25, 50)); setLimit(n); }}>Set</Button>
              </InlineStack>
            </InlineStack>
          </InlineStack>

          {/* ... keep loading/error/table/pagination exactly as before ... */}
          {/* (Your IndexTable + Pagination + Modal code stays unchanged) */}
```

> Tip: the debounce in `setQuery` means you can also call `setQuery(buildQuery())` on every keystroke for live search; the ‚ÄúSearch‚Äù button gives explicit control.

---

### 4) Optional query patterns

You can let users search with richer syntax (all supported by Shopify Admin GraphQL product search):

* Title contains: `title:*socks*`
* Exact title: `title:"Wool Socks"`
* Status: `status:active` | `status:draft` | `status:archived`
* Vendor/type: `vendor:"Acme"` `product_type:"Shoes"`
* Created after: `created_at:>2025-01-01`

Your UI can append these tokens to the query string.

---

### 5) Done

You now have:

* GraphQL-backed products with **cursor pagination**
* **Search + status filter** wired to the `$query` param
* Debounced fetching to keep requests snappy

---

## Adding An Export UI

Awesome ‚Äî here‚Äôs a **bulk select + Export CSV** add-on for your Products table. It‚Äôs client-side (no new backend route) and exports either the **selected** rows or, if nothing is selected, the **current page**.

---

### 1) Update imports (Polaris hook)

In your `/app` route‚Äôs `<script type="module">` import list, add `useIndexResourceState`:

```js
import {
  AppProvider, Page, Card, Text, InlineStack, Box, Button,
  IndexTable, TextField, Pagination, Modal, Thumbnail, Badge, Divider, Select,
  useIndexResourceState
} from "https://esm.sh/@shopify/polaris@12.11.0";
```

---

### 2) Add bulk-selection + CSV to `ProductsCard`

Replace your existing `ProductsCard` component with this version (everything else in your file stays the same). Differences:

* enables **row selection** via `useIndexResourceState`
* adds an **Export CSV** bulk action
* if **no rows selected**, it exports the **visible page**

```js
function ProductsCard({app, shop}) {
  const {loading, error, items, pageInfo, next, prev, setLimit, setQuery, q} = useProducts(app, shop);
  const [limitStr, setLimitStr] = React.useState(String(pageInfo.limit || 25));

  // Detail modal state (unchanged)
  const [detailOpen, setDetailOpen] = React.useState(false);
  const [detailLoading, setDetailLoading] = React.useState(false);
  const [detailError, setDetailError] = React.useState(null);
  const [product, setProduct] = React.useState(null);

  const openDetail = async (id) => {
    setDetailOpen(true); setDetailLoading(true); setDetailError(null);
    try { setProduct(await fetchProductDetail(app, shop, id)); }
    catch (e) { setDetailError(String(e)); }
    finally { setDetailLoading(false); }
  };
  const closeDetail = () => { setDetailOpen(false); setProduct(null); setDetailError(null); };

  // Search/status controls
  const [searchText, setSearchText] = React.useState('');
  const [status, setStatus] = React.useState('');
  const buildQuery = React.useCallback(() => {
    const parts = [];
    if (searchText.trim()) parts.push(`title:*${searchText.trim()}*`);
    if (status) parts.push(`status:${status}`);
    return parts.join(' ');
  }, [searchText, status]);
  const applySearch = () => setQuery(buildQuery());

  // Table rows (include handle if you added it to your GraphQL response)
  const rows = (items || []).map((p) => ({
    id: p.id,
    title: p.title || '(untitled)',
    status: p.status || '‚Äî',
    price: p.price || '‚Äî',
    inv: p.inv ?? '‚Äî',
    handle: p.handle || '‚Äî'
  }));
  const resourceName = { singular: 'product', plural: 'products' };

  // Bulk selection via Polaris helper
  const {
    selectedResources,
    allResourcesSelected,
    handleSelectionChange,
    clearSelection
  } = useIndexResourceState(rows, { resourceIDResolver: (r) => r.id });

  // CSV export
  const exportCSV = () => {
    const selectedIds = new Set(selectedResources);
    const toExport = selectedIds.size ? rows.filter(r => selectedIds.has(r.id)) : rows;

    const headers = ['id','title','status','price_first_variant','inventory_first_variant','handle'];
    const esc = (v) => {
      const s = (v == null ? '' : String(v));
      return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
    };
    const lines = [headers.join(',')];
    for (const r of toExport) {
      lines.push([r.id, r.title, r.status, r.price, r.inv, r.handle].map(esc).join(','));
    }
    const blob = new Blob([lines.join('\n')], {type:'text/csv;charset=utf-8;'});
    const ts = new Date().toISOString().replace(/[-:T]/g,'').slice(0,15);
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `products_${toExport.length}_rows_${ts}.csv`;
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(a.href);
    a.remove();
  };

  // Bulk actions menu
  const bulkActions = [
    { content: 'Export CSV (selected / page)', onAction: exportCSV },
    { content: 'Clear selection', onAction: clearSelection }
  ];

  return (
    <>
      <Card>
        <Box padding="400">
          {/* Header with search / status / per-page */}
          <InlineStack gap="400" align="space-between" wrap>
            <Text as="h2" variant="headingLg">Products</Text>

            <InlineStack gap="200" align="center" wrap>
              <TextField
                label="Search"
                labelHidden
                placeholder="Search title‚Ä¶"
                value={searchText}
                onChange={setSearchText}
                autoComplete="off"
              />
              <Select
                label="Status"
                labelHidden
                options={[
                  {label:'Any status', value:''},
                  {label:'Active', value:'active'},
                  {label:'Draft', value:'draft'},
                  {label:'Archived', value:'archived'},
                ]}
                onChange={setStatus}
                value={status}
              />
              <Button onClick={applySearch}>Search</Button>

              <InlineStack gap="200" align="center">
                <Text as="span" variant="bodyMd">Per page:</Text>
                <TextField
                  label="Limit"
                  labelHidden
                  value={limitStr}
                  onChange={(v)=>setLimitStr(v)}
                  onBlur={()=>{ const n = Math.max(1, Math.min(parseInt(limitStr||'25',10)||25, 50)); setLimit(n); }}
                  autoComplete="off"
                  inputMode="numeric"
                  type="text"
                  maxLength={2}
                />
                <Button onClick={()=>{ const n = Math.max(1, Math.min(parseInt(limitStr||'25',10)||25, 50)); setLimit(n); }}>Set</Button>
              </InlineStack>
            </InlineStack>
          </InlineStack>

          {/* Body */}
          {loading && <Box paddingBlockStart="300"><Text as="p">Loading products‚Ä¶</Text></Box>}
          {error && (
            <Box paddingBlockStart="300">
              <Text as="p" tone="critical">Error: {error}</Text>
              <Box paddingBlockStart="200"><Button onClick={()=>window.location.reload()}>Reload</Button></Box>
            </Box>
          )}

          {!loading && !error && (
            <>
              <IndexTable
                resourceName={resourceName}
                itemCount={rows.length}
                headings={[
                  {title: 'Title'},
                  {title: 'Status'},
                  {title: 'Price (1st variant)'},
                  {title: 'Inventory (1st variant)'},
                  {title: 'Actions'}
                ]}
                selectable
                selectedItemsCount={
                  allResourcesSelected ? 'All' : selectedResources.length
                }
                onSelectionChange={handleSelectionChange}
                bulkActions={bulkActions}
              >
                {rows.map((r, idx) => (
                  <IndexTable.Row id={r.id} key={r.id} position={idx} selected={selectedResources.includes(r.id)}>
                    <IndexTable.Cell><Text as="span" variant="bodyMd">{r.title}</Text></IndexTable.Cell>
                    <IndexTable.Cell>{r.status}</IndexTable.Cell>
                    <IndexTable.Cell>{r.price}</IndexTable.Cell>
                    <IndexTable.Cell>{r.inv}</IndexTable.Cell>
                    <IndexTable.Cell>
                      <Button onClick={()=>openDetail(r.id)}>View</Button>
                    </IndexTable.Cell>
                  </IndexTable.Row>
                ))}
              </IndexTable>

              <Box paddingBlockStart="300">
                <Pagination
                  hasPrevious={!!pageInfo.has_prev}
                  onPrevious={prev || (()=>{})}
                  hasNext={!!pageInfo.has_next}
                  onNext={next || (()=>{})}
                />
              </Box>
            </>
          )}
        </Box>
      </Card>

      {/* Detail modal (unchanged) */}
      <Modal
        open={detailOpen}
        onClose={closeDetail}
        title={product?.title || 'Product details'}
        primaryAction={{ content: 'Close', onAction: closeDetail }}
      >
        <Modal.Section>
          {detailLoading && <Text as="p">Loading‚Ä¶</Text>}
          {detailError && <Text as="p" tone="critical">Error: {detailError}</Text>}
          {!detailLoading && !detailError && product && (
            <Box>
              {/* ‚Ä¶ keep your existing modal body exactly as before ‚Ä¶ */}
            </Box>
          )}
        </Modal.Section>
      </Modal>
    </>
  );
}
```

---

### Notes / Options

* **Fields in CSV**: right now it exports: `id,title,status,price_first_variant,inventory_first_variant,handle`. Add more by extending your GraphQL selection and the row mapping.
* **Large exports**: for thousands of products, consider a server-side job that iterates cursors and streams a CSV file (then provide a downloadable link). For quick wins, the client-side export above is perfect for the current page or selected rows.
* **Clear selection** after exporting: call `clearSelection()` at the end of `exportCSV()` if you want that behavior.

---

## Adding Server-Side CSV Export

Perfect‚Äîhere‚Äôs a **server-side CSV export** endpoint that walks all products via **GraphQL cursor pagination** and streams a downloadable CSV. It reuses your existing session-token verification and the offline session from the Shopify PHP library.

---

### 1) Add `GET /api/export` (streaming CSV)

Drop this route **above** your 404 in `index.php`.

```php
use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Shopify\Utils;
use Shopify\Clients\Graphql;

if ($path === '/api/export') {
    // --- 0) Parse & validate inputs ---
    $shop = sanitizeShop($_GET['shop'] ?? '') ?? fail('Missing shop.');
    $queryQ = trim((string)($_GET['q'] ?? ''));       // optional: filter query
    $maxRows = (int)($_GET['max_rows'] ?? 0);         // optional hard cap; 0 = no cap
    $perPage = (int)($_GET['per_page'] ?? 250);       // GraphQL max for connections is typically 250
    $perPage = max(1, min($perPage, 250));
    setCsp($shop);

    // --- 1) Verify session token from App Bridge (Authorization: Bearer <token>) ---
    $auth = $_SERVER['HTTP_AUTHORIZATION'] ?? '';
    if (!preg_match('/^Bearer\s+(.+)$/i', $auth, $m)) fail('Missing Bearer token');
    try {
        $decoded = JWT::decode($m[1], new Key(SHOPIFY_API_SECRET, 'HS256'));
        if (($decoded->aud ?? null) !== SHOPIFY_API_KEY) fail('Bad audience');
        $iss = (string)($decoded->iss ?? '');
        if (stripos($iss, $shop) === false) fail('Issuer/shop mismatch');
    } catch (Throwable $e) {
        fail('Invalid session token: ' . $e->getMessage());
    }

    // --- 2) Load OFFLINE session (must match isOnline=false you used in OAuth) ---
    $req = makeLibraryRequest();
    $session = Utils::loadCurrentSession($req['headers'], $req['cookies'], false);
    if (!$session || strtolower($session->getShop()) !== strtolower($shop)) {
        fail('No valid offline session for this shop. Reinstall.');
    }

    // --- 3) Prepare GraphQL client & query ---
    $client = new Graphql($session->getShop(), $session->getAccessToken());

    $gql = <<<'GQL'
query ProductsExport($first: Int!, $after: String, $query: String) {
  products(first: $first, after: $after, query: $query, sortKey: CREATED_AT, reverse: true) {
    edges {
      cursor
      node {
        id
        title
        status
        handle
        createdAt
        variants(first: 1) {
          edges {
            node {
              price { amount currencyCode }
              inventoryQuantity
            }
          }
        }
      }
    }
    pageInfo {
      hasNextPage
      endCursor
    }
  }
}
GQL;

    // --- 4) CSV streaming headers ---
    $ts = gmdate('Ymd_His');
    header('Content-Type: text/csv; charset=utf-8');
    header("Content-Disposition: attachment; filename=products_export_{$ts}.csv");
    header('Cache-Control: no-store');

    // If your environment buffers output, turn it down for streaming:
    @ini_set('output_buffering', 'off');
    @ini_set('zlib.output_compression', '0');
    @set_time_limit(0);

    // --- 5) Open output and write header row ---
    $out = fopen('php://output', 'w');
    $headers = [
        'id','title','status','handle','created_at',
        'price_first_variant_amount','price_first_variant_currency','inventory_first_variant'
    ];
    fputcsv($out, $headers);

    // Helper to flush bytes as we go
    $flush = function () { if (function_exists('ob_flush')) @ob_flush(); flush(); };

    // --- 6) Walk cursors and stream rows ---
    $after = null;
    $total = 0;
    do {
        // Backoff/retry wrapper (simple)
        $attempts = 0;
        RETRY_BLOCK:
        $attempts++;
        $resp = $client->query([
            'query' => $gql,
            'variables' => [
                'first'  => $perPage,
                'after'  => $after,
                'query'  => ($queryQ !== '' ? $queryQ : null),
            ],
        ]);

        // Parse body (handle occasional transient errors)
        $body = $resp->getDecodedBody();
        if (!empty($body['errors']) && $attempts < 3) {
            // brief sleep then retry
            usleep(250_000);
            goto RETRY_BLOCK;
        } elseif (!empty($body['errors'])) {
            // Emit a single-row CSV error note (keeps response a CSV)
            fputcsv($out, ['ERROR', json_encode($body['errors']), '', '', '', '', '', '']);
            break;
        }

        $products = $body['data']['products'] ?? null;
        if (!$products || empty($products['edges'])) break;

        foreach ($products['edges'] as $edge) {
            $n = $edge['node'];
            $vEdge = $n['variants']['edges'][0]['node'] ?? null;
            $priceAmt = $vEdge['price']['amount'] ?? '';
            $priceCur = $vEdge['price']['currencyCode'] ?? '';
            $inv      = $vEdge['inventoryQuantity'] ?? '';

            fputcsv($out, [
                $n['id'] ?? '',
                $n['title'] ?? '',
                $n['status'] ?? '',
                $n['handle'] ?? '',
                $n['createdAt'] ?? '',
                $priceAmt,
                $priceCur,
                $inv,
            ]);
            $total++;
            if ($maxRows > 0 && $total >= $maxRows) {
                $after = null;
                break;
            }
        }

        $flush();

        if ($maxRows > 0 && $total >= $maxRows) {
            break;
        }

        $hasNext = $products['pageInfo']['hasNextPage'] ?? false;
        $after   = $hasNext ? ($products['pageInfo']['endCursor'] ?? null) : null;
    } while ($after);

    fclose($out);
    // Done. (We intentionally do not print any trailing text.)
    exit;
}
```

#### How it works

* Accepts `shop`, optional `q` (same query syntax you‚Äôre already using), optional `per_page` (‚â§250) and `max_rows`.
* Streams CSV rows as they‚Äôre fetched‚Äîmemory friendly.
* Simple retry loop for transient GraphQL errors.
* Uses your existing **App Bridge session token** (Bearer) + **offline session**.

---

### 2) Frontend: add a button to trigger the export

In your `/app` React UI, add an **Export CSV (all pages)** button near your search controls. It will:

* get a fresh session token,
* open `/api/export?...` in a new window with `Authorization` passed via a **signed URL** trick is not possible‚Äîso we‚Äôll attach the token via a programmatic `fetch` then **blob-download**.

Add this helper in your `<script type="module">`:

```js
async function downloadExportCSV(app, shop, q) {
  const token = await getSessionToken(app);
  const qs = new URLSearchParams({ shop });
  if (q && q.trim()) qs.set('q', q.trim());
  const res = await fetch('/api/export?' + qs.toString(), {
    headers: { Authorization: 'Bearer ' + token }
  });
  if (!res.ok) throw new Error('Export failed: HTTP ' + res.status);
  const blob = await res.blob();
  const a = document.createElement('a');
  const ts = new Date().toISOString().replace(/[-:T]/g,'').slice(0,15);
  a.href = URL.createObjectURL(blob);
  a.download = `products_export_${ts}.csv`;
  document.body.appendChild(a);
  a.click();
  URL.revokeObjectURL(a.href);
  a.remove();
}
```

Then, in your `ProductsCard` header (next to **Search**), add:

```jsx
<Button onClick={() => downloadExportCSV(app, shop, buildQuery())}>
  Export CSV (all pages)
</Button>
```

---

### 3) Notes and options

* **Speed & scale:** This streams page-by-page (up to 250 per page). For very large catalogs, consider Shopify‚Äôs **Bulk Operations** (GraphQL) for truly massive exports, then poll the file URL. This endpoint is great up to tens of thousands of products.
* **Server limits:** We set `set_time_limit(0)` and flush output; ensure your host allows long-running responses if exporting large catalogs.
* **Columns:** Modify the GraphQL selection + `fputcsv` fields to include more data (e.g., vendor, productType, tags).
* **Filters:** Your existing search UI composes `q`. Users can export exactly what they filtered.
